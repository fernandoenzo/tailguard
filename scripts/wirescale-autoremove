#!/usr/bin/env sh

calculate_sleep_time() {
  desired_seconds_list=$1
  current_second=$(date +%S | awk '{print int($1)}')
  for sec in $desired_seconds_list; do
    if [ "$current_second" -lt "$sec" ]; then
      echo $((sec - current_second))
      return
    fi
  done
  first=$(echo "$desired_seconds_list" | awk '{print $1}')
  echo $((60 - current_second + first))
}

get_sleep_times() {
  start_time=$(($1 % 60))
  num1=$(((start_time + 20) % 60))
  num2=$(((start_time + 40) % 60))
  echo "$start_time $num1 $num2" | tr " " "\n" | sort -n | tr "\n" " "
}

latest_handshake_less_than() {
  interface=$1
  remote_pubkey=$2
  seconds=$3

  ip ! link show "$interface" > /dev/null 2>&1 && return 1
  latest_handshake=$(wg show "$interface" latest-handshakes | awk -v pubkey="$remote_pubkey" '$1 == pubkey {print $2}')
  difference=$(($(date +%s) - latest_handshake))
  [ "$difference" -lt "$seconds" ]
  return
}

force_handshake() {
  interface=$1
  remote_pubkey=$2
  control="/run/wirescale/control/$interface.conf"
  wg-quick strip "/run/wirescale/$interface.conf" > "$control"
  wg set "$interface" peer "$remote_pubkey" remove
  wg syncconf "$interface" "$control"
  rm -rf "$control"
}

ping_periodic() {
  interface=$1
  ip=$2

  start_time=$(date +%s)

  while { ip link show "$interface"; } > /dev/null 2>&1 && [ $(($(date +%s) - start_time)) -lt 7200 ]; do
    ping -q -I "$interface" -c 1 -W 0.05 "$ip" > /dev/null 2>&1
    sleep 5
  done
}

assure_connection() {
  interface=$1
  remote_pubkey=$2
  file=$3

  listen_port=$(wg show "$interface" listen-port)
  endpoint=$(wg show "$interface" endpoints | awk -v pubkey="$remote_pubkey" '$1 == pubkey {print $2}')
  [ -z $endpoint ] && echo "Interface $interface has no peer with public key $remote_pubkey" && return 0
  wg set "$interface" listen-port 0
  { cat "$file" | socat UDP:"$endpoint",sourceport="$listen_port" -; } > /dev/null 2>&1
  wg set "$interface" listen-port "$listen_port"
}

change_keepalive() {
  interface=$1
  remote_pubkey=$2
  seconds=$3
  wg set "$interface" peer "$remote_pubkey" persistent-keepalive "$seconds"
}

ping_keepalive() {
  interface=$1
  remote_pubkey=$2
  wg_ip=$3
  is_remote=$4
  start_time=$5

  start_time_func=$(date +%s)

  ping_periodic "$interface" "$wg_ip" &

  while { ip link show "$interface"; } > /dev/null 2>&1 && [ $(($(date +%s) - start_time_func)) -lt 7200 ]; do
    if [ "$is_remote" -eq 1 ]; then
      sleep_times=$(get_sleep_times "$start_time")
      sleep "$(calculate_sleep_time "$sleep_times")"
    else
      start_time=$(((start_time + 10) % 60))
      sleep_times=$(get_sleep_times "$start_time")
      sleep "$(calculate_sleep_time "$sleep_times")"
    fi
    change_keepalive "$interface" "$remote_pubkey" 1
    sleep 5
    change_keepalive "$interface" "$remote_pubkey" 10
  done
}

autoremove() {
  interface=$1
  remote_pubkey=$2
  wg_ip=$3
  is_remote=$4
  start_time=$5

  start_time_func=$(date +%s)
  last_received=0

  sleep 10 # A brief pause to ensure both peers have sufficient time for proper setup

  ping_keepalive "$interface" "$remote_pubkey" "$is_remote" "$start_time" &

  dummy_file="/tmp/dummy-$interface.zip"
  if [ "$is_remote" -eq 0 ]; then
    {
      for i in 1 2; do
        sleep 360
        dd if=/dev/urandom of="$dummy_file" bs=1K count=$((i + 1)) > /dev/null 2>&1
        echo "Sending special package to assure connection"
        assure_connection "$interface" "$remote_pubkey" "$dummy_file"
        rm -rf "$dummy_file"
      done
    } &
  else
    {
      for i in 1 2; do
        sleep 720
        dd if=/dev/urandom of="$dummy_file" bs=1K count=$((i + 1)) > /dev/null 2>&1
        echo "Sending special package to assure connection"
        assure_connection "$interface" "$remote_pubkey" "$dummy_file"
        rm -rf "$dummy_file"
      done
    } &
  fi

  while { ip link show "$interface"; } > /dev/null 2>&1; do
    if [ $(($(date +%s) - start_time_func)) -ge 7200 ]; then
      echo "Terminating the primary autoremove function, as over two hours have elapsed since the script began"
      autoremove_three_min "$interface"
    fi
    received=$(wg show "$interface" transfer | awk -v pubkey="$remote_pubkey" '$1 == pubkey {print $2}')
    if [ "$received" -gt "$last_received" ]; then
      last_received=$received
    else
      echo "Connection appears to be broken. Trying to force a handshake..."
      if latest_handshake_less_than "$interface" "$remote_pubkey" 10; then
        echo "...but the latest handshake was less than ten seconds ago, so won't do anything"
      else
        force_handshake "$interface" "$remote_pubkey"
        count=0
        while [ $count -le 10 ]; do
          sleep 0.5
          count=$((count + 1))
        done
        if [ $count -le 10 ]; then
          echo "Connection recovered!"
        else
          break
        fi
      fi
    fi
    sleep 40
  done

  echo "Removing interface $interface"
  wg-quick down "/run/wirescale/$interface.conf"
  return 0
}

autoremove_three_min() {
  interface=$1

  echo "Launching autoremove function to check for handshakes older than 3 minutes"
  while { ip link show "$interface"; } > /dev/null 2>&1; do
    if ! latest_handshake_less_than "$interface" "$remote_pubkey" 180; then
      echo "Connection broken. More than three minutes without handshake. Removing interface $interface"
      wg-quick down "/run/wirescale/$interface.conf"
      exit 0
    fi
    sleep 30
  done
}

# Ensure at least one argument (the function name) was provided
if [ "$#" -eq 0 ]; then
  echo "Error: You must provide the function name as the first argument."
  exit 1
fi

# Extract the first argument and then remove it from the argument list
func_name=$1
shift

# Verify the function exists before attempting to invoke it
if type "$func_name" > /dev/null 2>&1; then
  "$func_name" "$@"
else
  echo "Error: The function $func_name does not exist in this script."
  exit 1
fi
